use criterion::{criterion_group, criterion_main, BenchmarkId, Criterion, Throughput};
use da_primitives::{BlockLengthColumns, BlockLengthRows};
use da_types::{AppExtrinsic, AppId};
use dusk_plonk::prelude::BlsScalar;
use kate::{
	com::{Cell, *},
	metrics::IgnoreMetrics,
	BlockDimensions, Seed, Serializable,
};
use kate_recovery::{
	com::reconstruct_extrinsics,
	commitments,
	data::{self, DataCell},
	index::*,
	matrix::Position,
	proof, testnet,
};
use rand::{prelude::IteratorRandom, Rng, SeedableRng};
use rand_chacha::ChaChaRng;
use sp_arithmetic::{traits::SaturatedConversion, Percent};

const XTS_JSON_SETS: &str = include_str!("reconstruct.data.json");

#[rustfmt::skip]
fn load_xts() -> Vec<Vec<AppExtrinsic>> {
	serde_json::from_str(XTS_JSON_SETS).expect("Autogenerated Json file .qed")
}

fn sample_cells_from_matrix(
	matrix: &[BlsScalar],
	dimensions: &BlockDimensions,
	columns: Option<&[u16]>,
) -> Vec<DataCell> {
	fn random_indexes(length: usize, seed: Seed) -> Vec<u16> {
		// choose random len/2 (unique) indexes
		let mut idx = (0..length).collect::<Vec<_>>();
		let mut chosen_idx = Vec::<u16>::new();
		let mut rng = ChaChaRng::from_seed(seed);

		for _ in 0..length / 2 {
			let i = rng.gen_range(0..idx.len());
			let v = idx.remove(i);
			chosen_idx.push(v as u16);
		}
		chosen_idx
	}

	const RNG_SEED: Seed = [42u8; 32];
	matrix
		.chunks_exact(dimensions.rows.as_usize().saturating_mul(2))
		.enumerate()
		.map(|(col, e)| (col as u16, e))
		.flat_map(|(col, e)| {
			random_indexes(e.len(), RNG_SEED)
				.into_iter()
				.map(|row| DataCell {
					position: Position {
						row: row as u32,
						col,
					},
					data: e[row as usize].to_bytes(),
				})
				.filter(|cell| {
					columns.is_none() || columns.unwrap_or(&[]).contains(&cell.position.col)
				})
				.collect::<Vec<_>>()
		})
		.collect::<Vec<_>>()
}

fn app_data_index_try_from_layout(
	layout: Vec<(AppId, u32)>,
) -> Result<AppDataIndex, AppDataIndexError> {
	let mut index = Vec::new();
	// transactions are ordered by application id
	// skip transactions with 0 application id - it's not a data txs
	let mut size = 0u32;
	let mut prev_app_id = AppId(0u32);

	for (app_id, data_len) in layout {
		if app_id.0 != 0 && prev_app_id != app_id {
			index.push((app_id.0, size));
		}

		size = size
			.checked_add(data_len)
			.ok_or(AppDataIndexError::SizeOverflow)?;
		if prev_app_id > app_id {
			return Err(AppDataIndexError::UnsortedLayout);
		}
		prev_app_id = app_id;
	}

	Ok(AppDataIndex { size, index })
}

fn random_cells(
	max_cols: BlockLengthColumns,
	max_rows: BlockLengthRows,
	percents: Percent,
) -> Vec<Cell> {
	let max_cols = max_cols.into();
	let max_rows = max_rows.into();

	let rng = &mut ChaChaRng::from_seed([0u8; 32]);
	let amount: usize = percents
		.mul_ceil::<u32>(max_cols * max_rows)
		.saturated_into();

	(0..max_cols)
		.flat_map(move |col| {
			(0..max_rows).map(move |row| Cell::new(BlockLengthRows(row), BlockLengthColumns(col)))
		})
		.choose_multiple(rng, amount)
}

fn bench_reconstruct(c: &mut Criterion) {
	let xts_sets = load_xts();

	let mut group = c.benchmark_group("reconstruct from xts");
	for xts in xts_sets.into_iter() {
		let size = xts
			.iter()
			.map(|app| app.data.len())
			.sum::<usize>()
			.try_into()
			.unwrap();
		group.throughput(Throughput::Bytes(size));
		group.sample_size(10);
		group.bench_with_input(BenchmarkId::from_parameter(size), &xts, |b, xts| {
			b.iter(|| reconstruct(xts.as_slice()))
		});
	}
	group.finish();
}

fn reconstruct(xts: &[AppExtrinsic]) {
	let metrics = IgnoreMetrics {};
	let (layout, commitments, dims, matrix) = par_build_commitments(
		BlockLengthRows(64),
		BlockLengthColumns(16),
		32,
		xts,
		Seed::default(),
		&metrics,
	)
	.unwrap();

	let columns = sample_cells_from_matrix(&matrix, &dims, None);
	let extended_dims = dims.try_into().unwrap();
	let index = app_data_index_try_from_layout(layout).unwrap();
	let reconstructed = reconstruct_extrinsics(&index, &extended_dims, columns).unwrap();
	for (result, xt) in reconstructed.iter().zip(xts) {
		assert_eq!(result.0, *xt.app_id);
		assert_eq!(result.1[0].as_slice(), &xt.data);
	}

	let public_params = testnet::public_params(dims.cols.as_usize());
	for cell in random_cells(dims.cols, dims.rows, Percent::one()) {
		let row = cell.row.as_usize();

		let proof = build_proof(&public_params, dims, &matrix, &[cell], &metrics).unwrap();
		assert_eq!(proof.len(), 80);

		let col: u16 = cell
			.col
			.0
			.try_into()
			.expect("`random_cells` function generates a valid `u16` for columns");
		let position = Position {
			row: cell.row.0,
			col,
		};
		let cell = data::Cell {
			position,
			content: proof.try_into().unwrap(),
		};

		let extended_dims = dims.try_into().unwrap();
		let commitment = commitments::from_slice(&commitments).unwrap()[row];
		let verification = proof::verify(&public_params, &extended_dims, &commitment, &cell);
		assert!(verification.is_ok());
		assert!(verification.unwrap());
	}
}

criterion_group! { benches, bench_reconstruct }
criterion_main!(benches);
