use criterion::{criterion_group, criterion_main, BenchmarkId, Criterion, Throughput};
use da_primitives::{BlockLengthColumns, BlockLengthRows};
use da_types::{AppExtrinsic, AppId};
use dusk_plonk::prelude::BlsScalar;
use kate::{
	com::{Cell, *},
	metrics::IgnoreMetrics,
	Seed, Serializable as _,
};
use kate_recovery::{
	com::reconstruct_extrinsics,
	commitments,
	data::{self, DataCell},
	index::*,
	matrix::Position,
	proof, testnet,
};
use nalgebra::DMatrix;
use rand::{prelude::IteratorRandom, Rng, SeedableRng};
use rand_chacha::ChaChaRng;
use sp_arithmetic::{traits::SaturatedConversion, Percent};

const XTS_JSON_SETS: &str = include_str!("reconstruct.data.json");

#[rustfmt::skip]
fn load_xts() -> Vec<Vec<AppExtrinsic>> {
	serde_json::from_str(XTS_JSON_SETS).expect("Autogenerated Json file .qed")
}

fn sample_cells_from_matrix(matrix: &DMatrix<BlsScalar>, columns: Option<&[u16]>) -> Vec<DataCell> {
	fn random_indexes(length: usize, seed: Seed) -> Vec<usize> {
		// choose random len/2 (unique) indexes
		let mut idx = (0..length).collect::<Vec<_>>();
		let mut chosen_idx = Vec::<usize>::new();
		let mut rng = ChaChaRng::from_seed(seed);

		for _ in 0..length / 2 {
			let i = rng.gen_range(0..idx.len());
			let v = idx.remove(i);
			chosen_idx.push(v);
		}
		chosen_idx
	}
	const RNG_SEED: Seed = [42u8; 32];

	let (rows, cols) = matrix.shape();
	let cols = u16::try_from(cols).unwrap();
	let indexes = random_indexes(rows, RNG_SEED);

	(0u16..cols)
		.filter(|col_idx| match &columns {
			None => true,
			Some(allowed) => allowed.contains(&col_idx),
		})
		.flat_map(|col_idx| {
			let col_view = matrix.column(col_idx.into()).data.into_slice();

			indexes
				.iter()
				.map(|row_idx| {
					let row_pos = u32::try_from(*row_idx).unwrap();
					let position = Position::new(row_pos, col_idx);
					debug_assert!(*row_idx < col_view.len());
					let data = col_view[*row_idx].to_bytes();
					DataCell::new(position, data)
				})
				.collect::<Vec<_>>()
		})
		.collect()
}

fn app_data_index_try_from_layout(
	layout: Vec<(AppId, u32)>,
) -> Result<AppDataIndex, AppDataIndexError> {
	let mut index = Vec::new();
	// transactions are ordered by application id
	// skip transactions with 0 application id - it's not a data txs
	let mut size = 0u32;
	let mut prev_app_id = AppId(0u32);

	for (app_id, data_len) in layout {
		if app_id.0 != 0 && prev_app_id != app_id {
			index.push((app_id.0, size));
		}

		size = size
			.checked_add(data_len)
			.ok_or(AppDataIndexError::SizeOverflow)?;
		if prev_app_id > app_id {
			return Err(AppDataIndexError::UnsortedLayout);
		}
		prev_app_id = app_id;
	}

	Ok(AppDataIndex { size, index })
}

fn random_cells(
	max_cols: BlockLengthColumns,
	max_rows: BlockLengthRows,
	percents: Percent,
) -> Vec<Cell> {
	let max_cols = max_cols.into();
	let max_rows = max_rows.into();

	let rng = &mut ChaChaRng::from_seed([0u8; 32]);
	let amount: usize = percents
		.mul_ceil::<u32>(max_cols * max_rows)
		.saturated_into();

	(0..max_cols)
		.flat_map(move |col| {
			(0..max_rows).map(move |row| Cell::new(BlockLengthRows(row), BlockLengthColumns(col)))
		})
		.choose_multiple(rng, amount)
}

fn bench_reconstruct(c: &mut Criterion) {
	let xts_sets = load_xts();

	let mut group = c.benchmark_group("reconstruct from xts");
	for xts in xts_sets.into_iter() {
		let size = xts
			.iter()
			.map(|app| app.data.len())
			.sum::<usize>()
			.try_into()
			.unwrap();
		group.throughput(Throughput::Bytes(size));
		group.sample_size(10);
		group.bench_with_input(BenchmarkId::from_parameter(size), &xts, |b, xts| {
			b.iter(|| reconstruct(xts.as_slice()))
		});
	}
	group.finish();
}

fn reconstruct(xts: &[AppExtrinsic]) {
	let metrics = IgnoreMetrics {};
	let (layout, commitments, dims, matrix) = par_build_commitments(
		BlockLengthRows(64),
		BlockLengthColumns(16),
		32,
		xts,
		Seed::default(),
		&metrics,
	)
	.unwrap();

	let columns = sample_cells_from_matrix(&matrix, None);
	let extended_dims = dims.try_into().unwrap();
	let index = app_data_index_try_from_layout(layout).unwrap();
	let reconstructed = reconstruct_extrinsics(&index, extended_dims, columns).unwrap();
	for (result, xt) in reconstructed.iter().zip(xts) {
		assert_eq!(result.0, *xt.app_id);
		assert_eq!(result.1[0].as_slice(), &xt.data);
	}

	let public_params = testnet::public_params(dims.cols.as_usize());
	for cell in random_cells(dims.cols, dims.rows, Percent::one()) {
		let row = cell.row.as_usize();

		let proof = build_proof(&public_params, dims, &matrix, &[cell], &metrics).unwrap();
		assert_eq!(proof.len(), 80);

		let col: u16 = cell
			.col
			.0
			.try_into()
			.expect("`random_cells` function generates a valid `u16` for columns");
		let position = Position {
			row: cell.row.0,
			col,
		};
		let cell = data::Cell {
			position,
			content: proof.try_into().unwrap(),
		};

		let extended_dims = dims.try_into().unwrap();
		let commitment = commitments::from_slice(&commitments).unwrap()[row];
		let verification = proof::verify(&public_params, extended_dims, &commitment, &cell);
		assert!(verification.is_ok());
		assert!(verification.unwrap());
	}
}

criterion_group! { benches, bench_reconstruct }
criterion_main!(benches);
